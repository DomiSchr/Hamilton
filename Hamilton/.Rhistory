range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
tmp <- FUN(p, i, mode)
output["i"]  <- tmp
}
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
test <- Hamilton(population, 160)
test
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
tmp <- FUN(p, i)
output["i"]  <- tmp
}
}
test <- Hamilton(population, 160)
test
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
output["i"] <- array(0, length(p[,1]))
output["i"] <- FUN(p, i)
}
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
# output["i"] <- array(0, length(p[,1]))
# output["i"] <- FUN(p, i)
print(paste("i"))
}
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
# output["i"] <- array(0, length(p[,1]))
# output["i"] <- FUN(p, i)
print(paste(i))
}
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
output[paste(i)] <- array(0, length(p[,1]))
# output["i"] <- FUN(p, i)
# print(paste(i))
}
return output
}
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
output[paste(i)] <- array(0, length(p[,1]))
# output["i"] <- FUN(p, i)
# print(paste(i))
}
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
# output[paste(i)] <- array(0, length(p[,1]))
output[paste(i)] <- FUN(p, i)
# print(paste(i))
}
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
# output[paste(i)] <- array(0, length(p[,1]))
output[paste(i)] <- FUN(p, i)
# print(paste(i))
}
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
output[paste(i)] <- array(0, length(p[,1]))
output[paste(i)] <- FUN(p, i)
# print(paste(i))
}
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
output[paste(i)] <- array(0, length(p))
output[paste(i)] <- FUN(p, i)
# print(paste(i))
}
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
# output[paste(i)] <- array(0, length(p))
# output[paste(i)] <- FUN(p, i)
tmp <- FUN(p, i)
print(tmp)
# print(paste(i))
}
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
# output[paste(i)] <- array(0, length(p))
output[paste(i)] <- FUN(p, i)
# tmp <- FUN(p, i)
# print(tmp)
# print(paste(i))
}
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
output[paste(i)] <- array(0, length(p))
output[paste(i)] <- FUN(p, i)
# tmp <- FUN(p, i)
# print(tmp)
# print(paste(i))
}
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
# output[paste(i)] <- array(0, length(p))
output[paste(i)] <- FUN(p, i)
# tmp <- FUN(p, i)
# print(tmp)
# print(paste(i))
}
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame()
for(i in h1:h2){
# output[paste(i)] <- array(0, length(p))
# output[paste(i)] <- FUN(p, i)
output[paste(i)] <- c(i, i+1, i+2)
# tmp <- FUN(p, i)
# print(tmp)
# print(paste(i))
}
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame(p)
for(i in h1:h2){
# output[paste(i)] <- array(0, length(p))
output[paste(i)] <- FUN(p, i)
# output[paste(i)] <- c(i, i+1, i+2)
# tmp <- FUN(p, i)
# print(tmp)
# print(paste(i))
}
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2) {
output <- data.frame(p)
for(i in h1:h2){
output[paste(i)] <- FUN(p, i)
}
output["p"] <- NULL
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
RangeHouseSizes <- function(FUN, p, h1, h2, mode = 0) {
output <- data.frame(p)
for(i in h1:h2){
output[paste(i)] <- FUN(p, i, mode)
}
output["p"] <- NULL
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 160, 169)
range
range <- RangeHouseSizes(Hamilton, population, 160, 169, 1)
range
range <- RangeHouseSizes(Hamilton, population, 160, 169, 2)
range
RangeHouseSizes <- function(FUN, p, h1, h2, mode = 0) {
output <- data.frame(p)
for(i in h1:h2){
output[paste(i)] <- FUN(p, i, mode)
}
output["p"] <- NULL
return(output)
}
range <- RangeHouseSizes(Hamilton, population, 169, 160, 2)
range
range <- RangeHouseSizes(Hamilton, population, 169, 160, 2)
range
RangeHouseSizes <- function(FUN, p, h1, h2, quota = 0) {
#  The method calculates a range of house sizes for the given Apportionment Method.
#  Author: Dominik Schröder
#
# Args:
#   FUN: the desired apportionment method
#   p: a vector containing the population of each state per column.
#   h1: the lower bound of the desired house size.
#   h2: the upper bound of the desired house size.
#   quota: if the apportionment method accepts a quota
#
# Returns:
#   A data frame containing the allotment for each state per row and the different house sizes per column.
output <- data.frame(p)
for(i in h1:h2){
output[paste(i)] <- FUN(p, i, quota)
}
output["p"] <- NULL
return(output)
}
# Start the Function with LeximinMethod(p, H)
# p is a vector, which represents the population sizes for each stateLe
# H is the House Size
# The function returns a vector, which represents the seat count for each state
Leximin <- function(p, H, quota) {
A <- sum(p) / H
a.share <- p / A
a <- p - p
# sets a to lower quota
for (i in 1:length(a)) {
a[i] <- floor(a.share[i])
}
# Calculates the depature of the apportionment a
CalcD <- function(p, a, A) {
delta <- ((p / a) - A) / A
d <- ifelse(delta < 0, delta * (-1), delta)
}
a <- ifelse( CalcD(p, a, A) > CalcD(p, a + 1, A), a + 1, a)
# Adds Seats until sum(a) euqals the House size
if (sum(a) < H) {
while (sum(a) < H) {
d <- CalcD(p, a + 1, A)
for(i in 1:length(d)) {
if (d[i] == min(d)) {
pos <- i
break
}
}
a[pos] <- a[pos] + 1
}
}
# Removes Seats until sum(a) euqals the House size
else {
while (sum(a) > H) {
d <- CalcD(p, a - 1, A)
for(i in 1:length(d)) {
if (d[i] == min(d)) {
pos <- i
break
}
}
a[pos] <- a[pos] - 1
}
}
return (a)
}
range <- RangeHouseSizes(Leximin, population, 169, 160, 2)
range
MinimumRange <- function(p, h) {
# Lexicographic Burt-Harris/Minimum range method for the Apportionment Problem
# Author: Dominik Schröder
#
# Args:
#   p: a vector containing the population of each state per column.
#   h: the house size as variable.
#
#
# Returns:
#   A Vector containing the optimized allotment of seats.
#
data <- data.frame("population" = p)
#__________________________________________________________________________
#Create arbitrary allotment
data["allotment"] <- array(0, length(data[, 1]))
tmp <- floor(h/length(p))
for(i in 1:length(data[, 1])){
data[i, "allotment"] <- tmp
}
count <- 1
while(sum(data[, "allotment"]) < h){
data[count, "allotment"] <- data[count, "allotment"] + 1
count <- (count + 1) %% h
}
#________________________________________________________________________
#Eingentlicher Algorithmus:
data["avg"] <- array(0, length(data[, 1]))
for (count in 0:(ceiling(length(data[, 1]) / 2))) {
#_________________________________________________________________________________________
#Biggest aj Value
max1 <- MaxDisparty(data)
#Optimization by adding one seat the the state with the largest average consituency size:
#TODO: Repeat this process until largest average consituency can't be optimized...
data <- CalcAvg(data)
if(count == 0){
ranks <- order(data[, "avg"])
}
#Wiederholtes addieren, bis es nichtmehr kleiner wird
bool <- 1
# browser()
while (bool == 1) {
data[ranks[length(ranks) - count], "allotment"]  <- data[ranks[length(ranks) - count], "allotment"] + 1
data <- CalcAvg(data)
max2 <- 0
bool <- 0
#Bei der ersten kleineren disparty wird abgebrochen!
for (i in 1:length(data[,1]))  {
if (i != ranks[length(ranks) - count]) {
data[i, "allotment"] <- data[i, "allotment"] - 1
data <- CalcAvg(data)
max2 <- MaxDisparty(data)
if (max2 >= max1) {
data[i, "allotment"] <- data[i, "allotment"] + 1
data <- CalcAvg(data)
} else {
max1 <- max2
bool <- bool + 1
break
}
}
}
if (bool == 0) {
data[ranks[length(ranks) - count], "allotment"]  <- data[ranks[length(ranks) - count], "allotment"] - 1
data <- CalcAvg(data)
}
}
#_________________________________________________________________________
#Smallest rj Value
max1 <- MaxDisparty(data)
#Optimization by adding one seat the the state with the largest average consituency size:
#TODO: Repeat this process until largest average consituency can't be optimized...
data <- CalcAvg(data)
#ranks <- order(data[, "avg"])
#Wiederholtes addieren, bis es nichtmehr kleiner wird
bool <- 1
while (bool == 1) {
data[ranks[1 + count], "allotment"]  <- data[ranks[1 + count], "allotment"] - 1
data <- CalcAvg(data)
max2 <- 0
bool <- 0
#Bei der ersten kleineren disparty wird abgebrochen!
for (i in 1:length(data[,1]))  {
if (i != ranks[1 + count]) {
data[i, "allotment"] <- data[i, "allotment"] + 1
data <- CalcAvg(data)
max2 <- MaxDisparty(data)
if (max2 >= max1) {
data[i, "allotment"] <- data[i, "allotment"] - 1
data <- CalcAvg(data)
} else {
max1 <- max2
bool <- bool + 1
break
}
}
}
if (bool == 0) {
data[ranks[1 + count], "allotment"]  <- data[ranks[1 + count], "allotment"] + 1
data <- CalcAvg(data)
}
}
}
return(data)
}
#Kann man evtl. optimieren!
# Größtes und kleinstes Element raussuchen und nur damit rechnen!
MaxDisparty1 <- function(data) {
max.disparty <- 0
for (i in 1:length(data[, 1])) {
for (j in 1:length(data[, 1])) {
tmp <-  abs(data[i, "avg"] / data[j, "avg"] - 1)
if (tmp > max.disparty) {
max.disparty <- tmp
}
}
}
return(max.disparty)
}
MaxDisparty <- function(data){
data <- CalcAvg(data)
max <- max(data[, "avg"])
min <- min(data[, "avg"])
return(abs((max/min)-1))
}
CalcAvg <- function(data){
for (i in 1:length(data[, 1])) {
data[i, "avg"] <- data[i, "population"] / data[i, "allotment"]
}
return(data)
}
RangeHouseSizes(Leximin, population, 169, 160, 2)
RangeHouseSizes(Leximin, population, 169, 160)
RangeHouseSizes(MinimumRange, population, 169, 160)
RangeHouseSizes <- function(FUN, p, h1, h2, variation = 0) {
#  The method calculates a range of house sizes for the given Apportionment Method.
#  Author: Dominik Schröder
#
# Args:
#   FUN: the desired apportionment method
#   p: a vector containing the population of each state per column.
#   h1: the lower bound of the desired house size.
#   h2: the upper bound of the desired house size.
#   variation(optional): enter value if the apportionment method accepts a variation eg. different quotas
#
# Returns:
#   A data frame containing the allotment for each state per row and the different house sizes per column.
if(h1 < 1 || h2 < 1){
stop("House size cannot be less than 1")
}
for(i in 1:length(p)){
if(p[1] < 1){
stop("Seat amount cannot be a negative value!")
}
}
output <- data.frame(p)
for (i in h1:h2) {
tryCatch({
tmp <- FUN(p, i, variation)},
error = function(e) {
tmp <- FUN(p, i)
}
)
output[paste(i)] <- tmp
}
output["p"] <- NULL
return(output)
}
RangeHouseSizes(MinimumRange, population, 169, 160)
MinimumRange(population, 160, 2)
RangeHouseSizes <- function(FUN, p, h1, h2, variation = 0) {
#  The method calculates a range of house sizes for the given Apportionment Method.
#  Author: Dominik Schröder
#
# Args:
#   FUN: the desired apportionment method
#   p: a vector containing the population of each state per column.
#   h1: the lower bound of the desired house size.
#   h2: the upper bound of the desired house size.
#   variation(optional): enter value if the apportionment method accepts a variation eg. different quotas
#
# Returns:
#   A data frame containing the allotment for each state per row and the different house sizes per column.
if(h1 < 1 || h2 < 1){
stop("House size cannot be less than 1")
}
for(i in 1:length(p)){
if(p[1] < 1){
stop("Seat amount cannot be a negative value!")
}
}
output <- data.frame(p)
calc = function(p, i, variation){
tryCatch({
tmp <- FUN(p, i, variation)},
error = function(e) {
tmp <- FUN(p, i)
}
)
return(tmp)
}
for (i in h1:h2) {
output[paste(i)] <- calc(p, i, variation)
}
output["p"] <- NULL
return(output)
}
RangeHouseSizes(Hamilton, population, 169, 160)
RangeHouseSizes(Hamilton, population, 169, 160, 1)
RangeHouseSizes(MinimumRange, population, 169, 160)
RangeHouseSizes(MinimumRange, population, 169, 160, 1)
