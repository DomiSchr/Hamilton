for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c")
population <- c(630, 480, 390)
p <- data.frame(states, population )
Hamilton(p,10)
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p[, 2])
a <- psum / h
share <- array(0, length(p))
share.floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- array(0, length(p))
p[["share.floor"]] <- NA
p[["fraction"]] <- NA
return(p)
p["share"] <- share
p["share.floor"] <- share.floor
p["fraction"] <- fraction
for (i in 1:length(p[,2])) {
p[i, "share"] <- p[i, 2] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c")
population <- c(630, 480, 390)
p <- data.frame(states, population )
Hamilton(p,10)
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p[, 2])
a <- psum / h
share <- array(0, length(p))
share.floor <- array(0, length(p))
fraction <- array(0, length(p))
return(length[p])
p[["share"]] <- array(0, length(p))
p[["share.floor"]] <- NA
p[["fraction"]] <- NA
p["share"] <- share
p["share.floor"] <- share.floor
p["fraction"] <- fraction
for (i in 1:length(p[,2])) {
p[i, "share"] <- p[i, 2] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c")
population <- c(630, 480, 390)
p <- data.frame(states, population )
Hamilton(p,10)
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p[, 2])
a <- psum / h
share <- array(0, length(p))
share.floor <- array(0, length(p))
fraction <- array(0, length(p))
browser()
return(length[p])
p[["share"]] <- array(0, length(p))
p[["share.floor"]] <- NA
p[["fraction"]] <- NA
p["share"] <- share
p["share.floor"] <- share.floor
p["fraction"] <- fraction
for (i in 1:length(p[,2])) {
p[i, "share"] <- p[i, 2] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c")
population <- c(630, 480, 390)
p <- data.frame(states, population )
Hamilton(p,10)
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p[, 2])
a <- psum / h
share <- array(0, length(p))
share.floor <- array(0, length(p))
fraction <- array(0, length(p))
return(length(p))
p[["share"]] <- array(0, length(p))
p[["share.floor"]] <- NA
p[["fraction"]] <- NA
p["share"] <- share
p["share.floor"] <- share.floor
p["fraction"] <- fraction
for (i in 1:length(p[,2])) {
p[i, "share"] <- p[i, 2] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c")
population <- c(630, 480, 390)
p <- data.frame(states, population )
Hamilton(p,10)
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p[, 2])
a <- psum / h
share <- array(0, length(p))
share.floor <- array(0, length(p))
fraction <- array(0, length(p))
return(length(p[1,]))
p[["share"]] <- array(0, length(p))
p[["share.floor"]] <- NA
p[["fraction"]] <- NA
p["share"] <- share
p["share.floor"] <- share.floor
p["fraction"] <- fraction
for (i in 1:length(p[,2])) {
p[i, "share"] <- p[i, 2] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c")
population <- c(630, 480, 390)
p <- data.frame(states, population )
Hamilton(p,10)
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p[, 2])
a <- psum / h
share <- array(0, length(p))
share.floor <- array(0, length(p))
fraction <- array(0, length(p))
return(length(p[,1]))
p[["share"]] <- array(0, length(p))
p[["share.floor"]] <- NA
p[["fraction"]] <- NA
p["share"] <- share
p["share.floor"] <- share.floor
p["fraction"] <- fraction
for (i in 1:length(p[,2])) {
p[i, "share"] <- p[i, 2] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c")
population <- c(630, 480, 390)
p <- data.frame(states, population )
Hamilton(p,10)
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p[, 2])
a <- psum / h
share <- array(0, length(p[,1]))
share.floor <- array(0, length(p[,1]))
fraction <- array(0, length(p[,1]))
p[["share"]] <- NA
p[["share.floor"]] <- NA
p[["fraction"]] <- NA
p["share"] <- share
p["share.floor"] <- share.floor
p["fraction"] <- fraction
for (i in 1:length(p[,2])) {
p[i, "share"] <- p[i, 2] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c")
population <- c(630, 480, 390)
p <- data.frame(states, population )
Hamilton(p,10)
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p[, 2])
a <- psum / h
share <- array(0, length(p[,1]))
share.floor <- array(0, length(p[,1]))
fraction <- array(0, length(p[,1]))
p["share"] <- share
p["share.floor"] <- share.floor
p["fraction"] <- fraction
for (i in 1:length(p[,2])) {
p[i, "share"] <- p[i, 2] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c")
population <- c(630, 480, 390)
p <- data.frame(states, population )
Hamilton(p,10)
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p[, 2])
a <- psum / h
#share <- array(0, length(p[,1]))
share.floor <- array(0, length(p[,1]))
fraction <- array(0, length(p[,1]))
p["share"] <- array(0, length(p[,1]))
p["share.floor"] <- share.floor
p["fraction"] <- fraction
for (i in 1:length(p[,2])) {
p[i, "share"] <- p[i, 2] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c")
population <- c(630, 480, 390)
p <- data.frame(states, population )
Hamilton(p,10)
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p[, 2])
a <- psum / h
p["share"] <- array(0, length(p[,1]))
p["share.floor"] <- array(0, length(p[,1]))
p["fraction"] <- array(0, length(p[,1]))
for (i in 1:length(p[,2])) {
p[i, "share"] <- p[i, 2] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c")
population <- c(630, 480, 390)
p <- data.frame(states, population )
Hamilton(p,10)
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p[, 2])
a <- psum / h
p["share"] <- array(0, length(p[,1]))
p["share.floor"] <- array(0, length(p[,1]))
p["fraction"] <- array(0, length(p[,1]))
for (i in 1:length(p[,2])) {
p[i, "share"] <- p[i, 2] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c" "d", "e")
population <- c(630, 480, 390, 500, 200)
p <- data.frame(states, population )
Hamilton(p,15)
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p[, 2])
a <- psum / h
p["share"] <- array(0, length(p[,1]))
p["share.floor"] <- array(0, length(p[,1]))
p["fraction"] <- array(0, length(p[,1]))
for (i in 1:length(p[,2])) {
p[i, "share"] <- p[i, 2] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
states <- c("a","b", "c", "d", "e")
population <- c(630, 480, 390, 500, 200)
p <- data.frame(states, population )
Hamilton(p,15)
source('E:/Proggen/Git/Hamilton/Hamilton/Hamilton.R')
source('E:/Proggen/Git/Hamilton/Hamilton/Hamilton.R')
source('E:/Proggen/Git/Hamilton/Hamilton/Hamilton.R')
source('E:/Proggen/Git/Hamilton/Hamilton/Hamilton.R')
