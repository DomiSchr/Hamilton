View(data)
View(data)
View(data)
MinimumRange <- function(p, a) {
# Lexicographic Burt-Harris/Minimum range method for the Apportionment Problem
#
# Args:
#   p: a vector containing the population of each state per column.
#   a: a vector containing the allotment of seats per column.
#
#
# Returns:
#   A Vector containing the optimized allotment of seats.
#
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[, 1]))
for (count in 0:(ceiling(length(data[, 1]) / 2))) {
#_________________________________________________________________________________________
#Biggest aj Value
max1 <- MaxDisparty(data)
#Optimization by adding one seat the the state with the largest average consituency size:
#TODO: Repeat this process until largest average consituency can't be optimized...
data <- CalcAvg(data)
ranks <- order(data[, "avg"])
#Wiederholtes addieren, bis es nichtmehr kleiner wird
max3 <- .Machine$integer.max
#C zum testen
c <- 0
while (c < 5) {
max3 <- max1
data[ranks[length(ranks) - count], "allotment"]  <- data[ranks[length(ranks) - count], "allotment"] + 1
data <- CalcAvg(data)
max2 <- 0
bool <- 0
#Bei der ersten kleineren disparty wird abgebrochen!
for (i in 1:length(data[,1]))  {
if (i != ranks[length(ranks)] - count) {
data[i, "allotment"] <- data[i, "allotment"] - 1
data <- CalcAvg(data)
max2 <- MaxDisparty(data)
if (max2 >= max1) {
data[i, "allotment"] <- data[i, "allotment"] + 1
data <- CalcAvg(data)
} else {
max1 <- max2
bool <- bool + 1
break
}
}
}
if (bool == 0) {
data[ranks[length(ranks) - count], "allotment"]  <- data[ranks[length(ranks) - count], "allotment"] - 1
data <- CalcAvg(data)
}
c <- c + 1
}
#_________________________________________________________________________
#Smallest rj Value
max1 <- MaxDisparty(data)
#Optimization by adding one seat the the state with the largest average consituency size:
#TODO: Repeat this process until largest average consituency can't be optimized...
data <- CalcAvg(data)
ranks <- order(data[, "avg"])
#Wiederholtes addieren, bis es nichtmehr kleiner wird
max3 <- .Machine$integer.max
#C zum testen
c <-0
while (c < 5) {
max3 <- max1
data[ranks[1 + count], "allotment"]  <- data[ranks[1 + count], "allotment"] + 1
data <- CalcAvg(data)
max2 <- 0
bool <- 0
#Bei der ersten kleineren disparty wird abgebrochen!
for (i in 1:length(data[,1]))  {
if (i != ranks[1 + count]) {
data[i, "allotment"] <- data[i, "allotment"] - 1
data <- CalcAvg(data)
max2 <- MaxDisparty(data)
if (max2 >= max1) {
data[i, "allotment"] <- data[i, "allotment"] + 1
data <- CalcAvg(data)
} else {
max1 <- max2
bool <- bool + 1
break
}
}
}
if (bool == 0) {
data[ranks[1 + count], "allotment"]  <- data[ranks[1 + count], "allotment"] - 1
data <- CalcAvg(data)
}
c <- c + 1
}
}
return(data)
}
#Kann man evtl. optimieren!
# Größtes und kleinstes Element raussuchen und nur damit rechnen!
MaxDisparty1 <- function(data) {
max.disparty <- 0
for (i in 1:length(data[, 1])) {
for (j in 1:length(data[, 1])) {
tmp <-  abs(data[i, "avg"] / data[j, "avg"] - 1)
if (tmp > max.disparty) {
max.disparty <- tmp
}
}
}
return(max.disparty)
}
MaxDisparty <- function(data){
data <- CalcAvg(data)
max <- max(data[, "avg"])
min <- min(data[, "avg"])
return(abs((max/min)-1))
}
CalcAvg <- function(data){
for (i in 1:length(data[, 1])) {
data[i, "avg"] <- data[i, "population"] / data[i, "allotment"]
}
return(data)
}
population <- c(282000, 566399, 623966, 193719, 187254, 269003, 238748, 170902, 112772, 176353, 452159, 498135, 108700, 259404, 302755, 134443, 239611, 160418, 74534)
allotment <- c(9, 19, 21, 6, 6, 9, 8, 6, 4, 6, 15, 17, 4, 9, 10, 5, 8, 5, 2)
data <- MinimumRange(population, allotment)
data
MinimumRange <- function(p, a) {
# Lexicographic Burt-Harris/Minimum range method for the Apportionment Problem
#
# Args:
#   p: a vector containing the population of each state per column.
#   a: a vector containing the allotment of seats per column.
#
#
# Returns:
#   A Vector containing the optimized allotment of seats.
#
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[, 1]))
for (count in 0:(ceiling(length(data[, 1]) / 2))) {
#_________________________________________________________________________________________
#Biggest aj Value
max1 <- MaxDisparty(data)
#Optimization by adding one seat the the state with the largest average consituency size:
#TODO: Repeat this process until largest average consituency can't be optimized...
data <- CalcAvg(data)
ranks <- order(data[, "avg"])
#Wiederholtes addieren, bis es nichtmehr kleiner wird
max3 <- .Machine$integer.max
#C zum testen
c <- 0
while (c < 5) {
max3 <- max1
data[ranks[length(ranks) - count], "allotment"]  <- data[ranks[length(ranks) - count], "allotment"] + 1
data <- CalcAvg(data)
max2 <- 0
bool <- 0
#Bei der ersten kleineren disparty wird abgebrochen!
for (i in 1:length(data[,1]))  {
browser()
if (i != ranks[length(ranks)] - count) {
data[i, "allotment"] <- data[i, "allotment"] - 1
data <- CalcAvg(data)
max2 <- MaxDisparty(data)
if (max2 >= max1) {
data[i, "allotment"] <- data[i, "allotment"] + 1
data <- CalcAvg(data)
} else {
max1 <- max2
bool <- bool + 1
break
}
}
}
if (bool == 0) {
data[ranks[length(ranks) - count], "allotment"]  <- data[ranks[length(ranks) - count], "allotment"] - 1
data <- CalcAvg(data)
}
c <- c + 1
}
#_________________________________________________________________________
#Smallest rj Value
max1 <- MaxDisparty(data)
#Optimization by adding one seat the the state with the largest average consituency size:
#TODO: Repeat this process until largest average consituency can't be optimized...
data <- CalcAvg(data)
ranks <- order(data[, "avg"])
#Wiederholtes addieren, bis es nichtmehr kleiner wird
max3 <- .Machine$integer.max
#C zum testen
c <-0
while (c < 5) {
max3 <- max1
data[ranks[1 + count], "allotment"]  <- data[ranks[1 + count], "allotment"] + 1
data <- CalcAvg(data)
max2 <- 0
bool <- 0
#Bei der ersten kleineren disparty wird abgebrochen!
for (i in 1:length(data[,1]))  {
if (i != ranks[1 + count]) {
data[i, "allotment"] <- data[i, "allotment"] - 1
data <- CalcAvg(data)
max2 <- MaxDisparty(data)
if (max2 >= max1) {
data[i, "allotment"] <- data[i, "allotment"] + 1
data <- CalcAvg(data)
} else {
max1 <- max2
bool <- bool + 1
break
}
}
}
if (bool == 0) {
data[ranks[1 + count], "allotment"]  <- data[ranks[1 + count], "allotment"] - 1
data <- CalcAvg(data)
}
c <- c + 1
}
}
return(data)
}
#Kann man evtl. optimieren!
# Größtes und kleinstes Element raussuchen und nur damit rechnen!
MaxDisparty1 <- function(data) {
max.disparty <- 0
for (i in 1:length(data[, 1])) {
for (j in 1:length(data[, 1])) {
tmp <-  abs(data[i, "avg"] / data[j, "avg"] - 1)
if (tmp > max.disparty) {
max.disparty <- tmp
}
}
}
return(max.disparty)
}
MaxDisparty <- function(data){
data <- CalcAvg(data)
max <- max(data[, "avg"])
min <- min(data[, "avg"])
return(abs((max/min)-1))
}
CalcAvg <- function(data){
for (i in 1:length(data[, 1])) {
data[i, "avg"] <- data[i, "population"] / data[i, "allotment"]
}
return(data)
}
population <- c(282000, 566399, 623966, 193719, 187254, 269003, 238748, 170902, 112772, 176353, 452159, 498135, 108700, 259404, 302755, 134443, 239611, 160418, 74534)
allotment <- c(9, 19, 21, 6, 6, 9, 8, 6, 4, 6, 15, 17, 4, 9, 10, 5, 8, 5, 2)
data <- MinimumRange(population, allotment)
data
View(data)
View(data)
source('~/Proggen/GitHub/Hamilton/Hamilton/MinimumRange.R')
population <- c(282000, 566399, 623966, 193719, 187254, 269003, 238748, 170902, 112772, 176353, 452159, 498135, 108700, 259404, 302755, 134443, 239611, 160418, 74534)
allotment <- c(9, 19, 21, 6, 6, 9, 8, 6, 4, 6, 15, 17, 4, 9, 10, 5, 8, 5, 2)
data <- MinimumRange(population, allotment)
data
View(data)
adamsallot <- c(9, 18, 20, 7, 6, 9, 8, 6, 4, 6, 15, 16, 4, 9, 10, 5, 8, 6, 3)
data <- MinimumRange(population, adamsallot)
data
data <- MinimumRange(population, adamsallot)
data
MinimumRange <- function(p, a) {
# Lexicographic Burt-Harris/Minimum range method for the Apportionment Problem
#
# Args:
#   p: a vector containing the population of each state per column.
#   a: a vector containing the allotment of seats per column.
#
#
# Returns:
#   A Vector containing the optimized allotment of seats.
#
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[, 1]))
for (count in 0:(ceiling(length(data[, 1]) / 2))) {
#_________________________________________________________________________________________
#Biggest aj Value
max1 <- MaxDisparty(data)
#Optimization by adding one seat the the state with the largest average consituency size:
#TODO: Repeat this process until largest average consituency can't be optimized...
data <- CalcAvg(data)
ranks <- order(data[, "avg"])
#Wiederholtes addieren, bis es nichtmehr kleiner wird
max3 <- .Machine$integer.max
#C zum testen
c <- 0
while (c < 5) {
max3 <- max1
data[ranks[length(ranks) - count], "allotment"]  <- data[ranks[length(ranks) - count], "allotment"] + 1
data <- CalcAvg(data)
max2 <- 0
bool <- 0
#Bei der ersten kleineren disparty wird abgebrochen!
for (i in 1:length(data[,1]))  {
#browser()
if (i != ranks[length(ranks)] - count) {
data[i, "allotment"] <- data[i, "allotment"] - 1
data <- CalcAvg(data)
max2 <- MaxDisparty(data)
if (max2 >= max1) {
data[i, "allotment"] <- data[i, "allotment"] + 1
data <- CalcAvg(data)
} else {
max1 <- max2
bool <- bool + 1
break
}
}
}
if (bool == 0) {
data[ranks[length(ranks) - count], "allotment"]  <- data[ranks[length(ranks) - count], "allotment"] - 1
data <- CalcAvg(data)
}
c <- c + 1
}
#_________________________________________________________________________
#Smallest rj Value
max1 <- MaxDisparty(data)
#Optimization by adding one seat the the state with the largest average consituency size:
#TODO: Repeat this process until largest average consituency can't be optimized...
data <- CalcAvg(data)
ranks <- order(data[, "avg"])
#Wiederholtes addieren, bis es nichtmehr kleiner wird
max3 <- .Machine$integer.max
#C zum testen
c <-0
while (c < 5) {
max3 <- max1
data[ranks[1 + count], "allotment"]  <- data[ranks[1 + count], "allotment"] + 1
data <- CalcAvg(data)
max2 <- 0
bool <- 0
#Bei der ersten kleineren disparty wird abgebrochen!
for (i in 1:length(data[,1]))  {
if (i != ranks[1 + count]) {
data[i, "allotment"] <- data[i, "allotment"] - 1
data <- CalcAvg(data)
max2 <- MaxDisparty(data)
if (max2 >= max1) {
data[i, "allotment"] <- data[i, "allotment"] + 1
data <- CalcAvg(data)
} else {
max1 <- max2
bool <- bool + 1
break
}
}
}
if (bool == 0) {
data[ranks[1 + count], "allotment"]  <- data[ranks[1 + count], "allotment"] - 1
data <- CalcAvg(data)
}
c <- c + 1
}
}
return(data)
}
#Kann man evtl. optimieren!
# Größtes und kleinstes Element raussuchen und nur damit rechnen!
MaxDisparty1 <- function(data) {
max.disparty <- 0
for (i in 1:length(data[, 1])) {
for (j in 1:length(data[, 1])) {
tmp <-  abs(data[i, "avg"] / data[j, "avg"] - 1)
if (tmp > max.disparty) {
max.disparty <- tmp
}
}
}
return(max.disparty)
}
MaxDisparty <- function(data){
data <- CalcAvg(data)
max <- max(data[, "avg"])
min <- min(data[, "avg"])
return(abs((max/min)-1))
}
CalcAvg <- function(data){
for (i in 1:length(data[, 1])) {
data[i, "avg"] <- data[i, "population"] / data[i, "allotment"]
}
return(data)
}
adamsallot <- c(9, 18, 20, 7, 6, 9, 8, 6, 4, 6, 15, 16, 4, 9, 10, 5, 8, 6, 3)
data <- MinimumRange(population, adamsallot)
data
MinimumRange <- function(p, a) {
# Lexicographic Burt-Harris/Minimum range method for the Apportionment Problem
#
# Args:
#   p: a vector containing the population of each state per column.
#   a: a vector containing the allotment of seats per column.
#
#
# Returns:
#   A Vector containing the optimized allotment of seats.
#
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[, 1]))
for (count in 0:(ceiling(length(data[, 1]) / 2))) {
#_________________________________________________________________________________________
#Biggest aj Value
max1 <- MaxDisparty(data)
#Optimization by adding one seat the the state with the largest average consituency size:
#TODO: Repeat this process until largest average consituency can't be optimized...
data <- CalcAvg(data)
ranks <- order(data[, "avg"])
#Wiederholtes addieren, bis es nichtmehr kleiner wird
bool <- 1
while (bool == 1) {
data[ranks[length(ranks) - count], "allotment"]  <- data[ranks[length(ranks) - count], "allotment"] + 1
data <- CalcAvg(data)
max2 <- 0
bool <- 0
#Bei der ersten kleineren disparty wird abgebrochen!
for (i in 1:length(data[,1]))  {
if (i != ranks[length(ranks)] - count) {
data[i, "allotment"] <- data[i, "allotment"] - 1
data <- CalcAvg(data)
max2 <- MaxDisparty(data)
if (max2 >= max1) {
data[i, "allotment"] <- data[i, "allotment"] + 1
data <- CalcAvg(data)
} else {
max1 <- max2
bool <- bool + 1
break
}
}
}
if (bool == 0) {
data[ranks[length(ranks) - count], "allotment"]  <- data[ranks[length(ranks) - count], "allotment"] - 1
data <- CalcAvg(data)
}
}
#_________________________________________________________________________
#Smallest rj Value
max1 <- MaxDisparty(data)
#Optimization by adding one seat the the state with the largest average consituency size:
#TODO: Repeat this process until largest average consituency can't be optimized...
data <- CalcAvg(data)
ranks <- order(data[, "avg"])
#Wiederholtes addieren, bis es nichtmehr kleiner wird
bool <- 1
while (bool == 1) {
data[ranks[1 + count], "allotment"]  <- data[ranks[1 + count], "allotment"] + 1
data <- CalcAvg(data)
max2 <- 0
bool <- 0
#Bei der ersten kleineren disparty wird abgebrochen!
for (i in 1:length(data[,1]))  {
if (i != ranks[1 + count]) {
data[i, "allotment"] <- data[i, "allotment"] - 1
data <- CalcAvg(data)
max2 <- MaxDisparty(data)
if (max2 >= max1) {
data[i, "allotment"] <- data[i, "allotment"] + 1
data <- CalcAvg(data)
} else {
max1 <- max2
bool <- bool + 1
break
}
}
}
if (bool == 0) {
data[ranks[1 + count], "allotment"]  <- data[ranks[1 + count], "allotment"] - 1
data <- CalcAvg(data)
}
}
}
return(data)
}
#Kann man evtl. optimieren!
# Größtes und kleinstes Element raussuchen und nur damit rechnen!
MaxDisparty1 <- function(data) {
max.disparty <- 0
for (i in 1:length(data[, 1])) {
for (j in 1:length(data[, 1])) {
tmp <-  abs(data[i, "avg"] / data[j, "avg"] - 1)
if (tmp > max.disparty) {
max.disparty <- tmp
}
}
}
return(max.disparty)
}
MaxDisparty <- function(data){
data <- CalcAvg(data)
max <- max(data[, "avg"])
min <- min(data[, "avg"])
return(abs((max/min)-1))
}
CalcAvg <- function(data){
for (i in 1:length(data[, 1])) {
data[i, "avg"] <- data[i, "population"] / data[i, "allotment"]
}
return(data)
}
data <- MinimumRange(population, adamsallot)
data
population <- c(282000, 566399, 623966, 193719, 187254, 269003, 238748, 170902, 112772, 176353, 452159, 498135, 108700, 259404, 302755, 134443, 239611, 160418, 74534)
allotment <- c(9, 19, 21, 6, 6, 9, 8, 6, 4, 6, 15, 17, 4, 9, 10, 5, 8, 5, 2)
adamsallot <- c(9, 18, 20, 7, 6, 9, 8, 6, 4, 6, 15, 16, 4, 9, 10, 5, 8, 6, 3)
data <- MinimumRange(population, allotment)
data
