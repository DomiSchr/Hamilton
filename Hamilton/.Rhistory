#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#   q: the quota. Choose: 0 for Hare Quota(Default)
#                         1 for Droop Quota
#                         2 for Hagenbach-Bischoff Quota
#                         3 for Imperiali Quota
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
if(h < 1){
stop("House size cannot be less than 1")
}
p <- data.frame(p)
psum <- sum(p[, 1])
if(q == 0){
#Hare Quota(Default):
a <- floor(psum / h)
} else if(q == 1){
#Droop Quota
a <- floor(1 + psum/(h + 1))
} else if(q == 2){
#Hagenbach-Bischoff Quota
a <-  floor(psum/(h + 1))
} else if(q == 3){
#Imperiali Quota
a <- floor(psum/(h + 2))
} else {
# Exception!
stop("Chosen quota option not valid!")
}
p["share.floor"] <- array(0, length(p[,1]))
p["fraction"] <- array(0, length(p[,1]))
for (i in 1:length(p[,1])) {
tmp <- p[i, 1] / a
if(tmp < 0){
stop("Seat amount cannot be a negative value!")
}
p[i, "share.floor"] <- floor(tmp)
p[i, "fraction"] <- tmp - floor(tmp)
}
if (sum(p[, "share.floor"]) == h) {
return(p[["share.floor"]])
}
p["result"] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(as.vector(p[["result"]])
}
Hamilton <- function(p, h, q = 0) {
#  Largest remainder method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#   q: the quota. Choose: 0 for Hare Quota(Default)
#                         1 for Droop Quota
#                         2 for Hagenbach-Bischoff Quota
#                         3 for Imperiali Quota
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
if(h < 1){
stop("House size cannot be less than 1")
}
p <- data.frame(p)
psum <- sum(p[, 1])
if(q == 0){
#Hare Quota(Default):
a <- floor(psum / h)
} else if(q == 1){
#Droop Quota
a <- floor(1 + psum/(h + 1))
} else if(q == 2){
#Hagenbach-Bischoff Quota
a <-  floor(psum/(h + 1))
} else if(q == 3){
#Imperiali Quota
a <- floor(psum/(h + 2))
} else {
# Exception!
stop("Chosen quota option not valid!")
}
p["share.floor"] <- array(0, length(p[,1]))
p["fraction"] <- array(0, length(p[,1]))
for (i in 1:length(p[,1])) {
tmp <- p[i, 1] / a
if(tmp < 0){
stop("Seat amount cannot be a negative value!")
}
p[i, "share.floor"] <- floor(tmp)
p[i, "fraction"] <- tmp - floor(tmp)
}
if (sum(p[, "share.floor"]) == h) {
return(p[["share.floor"]])
}
p["result"] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(as.vector(p[["result"]]))
}
Hamilton(c(630, 480, 390, 500),10, 1)
Hamilton(c(630, 480, 390, 500),10, 3)
Hamilton <- function(p, h, q = 0) {
#  Largest remainder method for the Apportionment Problem
#
# Args:
#   p: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column.
#   h: the house size as variable.
#   q: the quota. Choose: 0 for Hare Quota(Default)
#                         1 for Droop Quota
#                         2 for Hagenbach-Bischoff Quota
#                         3 for Imperiali Quota
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
if(h < 1){
stop("House size cannot be less than 1")
}
p <- data.frame(p)
psum <- sum(p[, 1])
if(q == 0){
#Hare Quota(Default):
a <- floor(psum / h)
} else if(q == 1){
#Droop Quota
a <- floor(1 + psum/(h + 1))
} else if(q == 2){
#Hagenbach-Bischoff Quota
a <-  floor(psum/(h + 1))
} else if(q == 3){
#Imperiali Quota
a <- floor(psum/(h + 2))
} else {
# Exception!
stop("Chosen quota option not valid!")
}
p["share.floor"] <- array(0, length(p[,1]))
p["fraction"] <- array(0, length(p[,1]))
for (i in 1:length(p[,1])) {
tmp <- p[i, 1] / a
if(tmp < 0){
stop("Seat amount cannot be a negative value!")
}
p[i, "share.floor"] <- floor(tmp)
p[i, "fraction"] <- tmp - floor(tmp)
}
if (sum(p[, "share.floor"]) == h) {
return(as.vector(p[["share.floor"]]))
}
p["result"] <- NA
p["result"] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(as.vector(p[["result"]]))
}
Hamilton(c(630, 480, 390, 500),10, 3)
Leximin(c(630, 480, 390, 500),10, 3)
# Start the Function with LeximinMethod(p, H)
# p is a vector, which represents the population sizes for each stateLe
# H is the House Size
# The function returns a vector, which represents the seat count for each state
Leximin <- function(p, H, quota) {
A <- sum(p) / H
a.share <- p / A
a <- p - p
# sets a to lower quota
for (i in 1:length(a)) {
a[i] <- floor(a.share[i])
}
# Calculates the depature of the apportionment a
CalcD <- function(p, a, A) {
delta <- ((p / a) - A) / A
d <- ifelse(delta < 0, delta * (-1), delta)
}
a <- ifelse( CalcD(p, a, A) > CalcD(p, a + 1, A), a + 1, a)
# Adds Seats until sum(a) euqals the House size
if (sum(a) < H) {
while (sum(a) < H) {
d <- CalcD(p, a + 1, A)
for(i in 1:length(d)) {
if (d[i] == min(d)) {
pos <- i
break
}
}
a[pos] <- a[pos] + 1
}
}
# Removes Seats until sum(a) euqals the House size
else {
while (sum(a) > H) {
d <- CalcD(p, a - 1, A)
for(i in 1:length(d)) {
if (d[i] == min(d)) {
pos <- i
break
}
}
a[pos] <- a[pos] - 1
}
}
return (a)
}
Leximin(c(630, 480, 390, 500),10, 3)
Hamilton(c(630, 480, 390, 500),10, 3)
MinimumRange <- function(p, h){
ranks <- order(p, decreasing = TRUE)
return(ranks)
}
test <- Hamilton(c(630, 480, 390, 500),10)
MinimumRange(test, 10)
?order
MinimumRange <- function(p, h, a){
data <- data.frame("population" = p, "h.size" = h)
ranks <- order(p)
return(data)
}
MinimumRange(test, 10)
MinimumRange <- function(p, h, a){
data <- data.frame("population" = p, "allotment" = h)
ranks <- order(p)
return(data)
}
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = h)
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"]
for(i in 1:length(data[, 1])){
data["avg", i] <- data["population", i] / data["allotment", i]
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(p[,1]))
for(i in 1:length(data[, 1])){
data["avg", i] <- data["population", i] / data["allotment", i]
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(p[1,]))
for(i in 1:length(data[, 1])){
data["avg", i] <- data["population", i] / data["allotment", i]
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[, 1])){
data["avg", i] <- data["population", i] / data["allotment", i]
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
# for(i in 1:length(data[, 1])){
#   data["avg", i] <- data["population", i] / data["allotment", i]
# }
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[, 1])){
data["avg", i] <- data["population", i] / data["allotment", i]
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[, 1])){
data[["avg", i]] <- data[["population", i]] / data[["allotment", i]]
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[, 1])){
data["avg", i] <- data[["population", i]] / data[["allotment", i]]
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[, 1])){
data["avg", i] <- p[i] / a[i]
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[1, ])){
data["avg", i] <- p[i] / a[i]
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[1, ])){
data["avg", i] <- p[i] / a[i]
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[1, ])){
data[i, "avg"] <- p[i] / a[i]
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[1, ])){
data[i, "avg"] <- p[i] / a[i]
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[1, ])){
data[i, "avg"] <- p[i] / a[i]
print(p[i] / a[i])
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[, 1])){
data[i, "avg"] <- p[i] / a[i]
print(p[i] / a[i])
}
ranks <- order(p)
return(data)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[, 1])){
data[i, "avg"] <- p[i] / a[i]
print(p[i] / a[i])
}
ranks <- order(data[, "avg"])
return(ranks)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[, 1])){
data[i, "avg"] <- p[i] / a[i]
}
ranks <- order(data[, "avg"])
return(ranks)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[, 1])){
data[i, "avg"] <- p[i] / a[i]
}
#Caclulate the maximum disparty:
max.disparty <- 0
for(i in 1:length(data[, 1])){
for(j in 1:length(data[, 1])){
tmp <-  data[i, "avg"] /data[j,"avg"]
if(tmp > max.disparty){
max.disparty <- tmp
}
}
}
ranks <- order(data[, "avg"])
return(max.disparty)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
MinimumRange <- function(p, a, h){
data <- data.frame("population" = p, "allotment" = a)
data["avg"] <- array(0, length(data[1,]))
for(i in 1:length(data[, 1])){
data[i, "avg"] <- p[i] / a[i]
}
#Caclulate the maximum disparty:
ranks <- order(data[, "avg"])
return(MaxDisparty(data))
}
MaxDisparty <- function(data){
max.disparty <- 0
for(i in 1:length(data[, 1])){
for(j in 1:length(data[, 1])){
tmp <-  data[i, "avg"] /data[j,"avg"]
if(tmp > max.disparty){
max.disparty <- tmp
}
}
}
return(max.disparty)
}
popu <- c(630, 480, 390, 500)
allot <- Hamilton(popu,10)
MinimumRange(popu, allot, 10)
