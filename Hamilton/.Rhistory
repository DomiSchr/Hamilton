return(p)
} else {
#TODO: Hier den Spaß weiter!! Sortieren und so!
ranks <- order(p$fraction)
return(ranks)
}
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H){
P <- sum(p2[,"population"])
A <- P/H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for(i in 1:length(p[["population"]])){
p[i,"share"] <- p[i,"population"]/A
p[i, "share_floor"] <- floor(p[i,"share"])
p[i, "fraction"] <-  p[i,"share"] - p[i, "share_floor"]
}
if(sum(p[, "share_floor"]) == H){
return(p)
} else {
#TODO: Hier den Spaß weiter!! Sortieren und so!
ranks <- order(p$fraction, decreasing = TRUE)
return(ranks)
}
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H){
P <- sum(p2[,"population"])
A <- P/H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for(i in 1:length(p[["population"]])){
p[i,"share"] <- p[i,"population"]/A
p[i, "share_floor"] <- floor(p[i,"share"])
p[i, "fraction"] <-  p[i,"share"] - p[i, "share_floor"]
}
if(sum(p[, "share_floor"]) == H){
return(p)
} else {
#TODO: Hier den Spaß weiter!! Sortieren und so!
p[["result"]] <- p[, share_floor]
return(p)
ranks <- order(p$fraction, decreasing = TRUE)
for(i in H - sum(p[, "share_floor"])){
ranks[1]
}
return(ranks)
}
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H){
P <- sum(p2[,"population"])
A <- P/H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for(i in 1:length(p[["population"]])){
p[i,"share"] <- p[i,"population"]/A
p[i, "share_floor"] <- floor(p[i,"share"])
p[i, "fraction"] <-  p[i,"share"] - p[i, "share_floor"]
}
if(sum(p[, "share_floor"]) == H){
return(p)
} else {
#TODO: Hier den Spaß weiter!! Sortieren und so!
tmp <- array(0, length(p))
tmp <- p[["result"]]
return(tmp)
ranks <- order(p$fraction, decreasing = TRUE)
for(i in H - sum(p[, "share_floor"])){
ranks[1]
}
return(ranks)
}
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H){
P <- sum(p2[,"population"])
A <- P/H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for(i in 1:length(p[["population"]])){
p[i,"share"] <- p[i,"population"]/A
p[i, "share_floor"] <- floor(p[i,"share"])
p[i, "fraction"] <-  p[i,"share"] - p[i, "share_floor"]
}
if(sum(p[, "share_floor"]) == H){
return(p)
} else {
#TODO: Hier den Spaß weiter!! Sortieren und so!
p[["result"]] <- replicate(1, p[["fraction"]])
return(p)
ranks <- order(p$fraction, decreasing = TRUE)
for(i in H - sum(p[, "share_floor"])){
ranks[1]
}
return(ranks)
}
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H){
P <- sum(p2[,"population"])
A <- P/H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for(i in 1:length(p[["population"]])){
p[i,"share"] <- p[i,"population"]/A
p[i, "share_floor"] <- floor(p[i,"share"])
p[i, "fraction"] <-  p[i,"share"] - p[i, "share_floor"]
}
if(sum(p[, "share_floor"]) == H){
return(p)
} else {
#TODO: Hier den Spaß weiter!! Sortieren und so!
p[["result"]] <- replicate(1, p[["share_floor"]])
return(p)
ranks <- order(p$fraction, decreasing = TRUE)
for(i in H - sum(p[, "share_floor"])){
ranks[1]
}
return(ranks)
}
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H){
P <- sum(p2[,"population"])
A <- P/H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for(i in 1:length(p[["population"]])){
p[i,"share"] <- p[i,"population"]/A
p[i, "share_floor"] <- floor(p[i,"share"])
p[i, "fraction"] <-  p[i,"share"] - p[i, "share_floor"]
}
if(sum(p[, "share_floor"]) == H){
return(p)
} else {
#TODO: Hier den Spaß weiter!! Sortieren und so!
p[["result"]] <- replicate(1, p[["share_floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for(i in H - sum(p[, "share_floor"])){
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(ranks)
}
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H){
P <- sum(p2[,"population"])
A <- P/H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for(i in 1:length(p[["population"]])){
p[i,"share"] <- p[i,"population"]/A
p[i, "share_floor"] <- floor(p[i,"share"])
p[i, "fraction"] <-  p[i,"share"] - p[i, "share_floor"]
}
if(sum(p[, "share_floor"]) == H){
return(p)
} else {
#TODO: Hier den Spaß weiter!! Sortieren und so!
p[["result"]] <- replicate(1, p[["share_floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for(i in H - sum(p[, "share_floor"])){
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
View(p2)
View(hamilton)
View(hamilton)
View(hamilton)
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H){
P <- sum(p2[,"population"])
A <- P/H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for(i in 1:length(p[["population"]])){
p[i,"share"] <- p[i,"population"]/A
p[i, "share_floor"] <- floor(p[i,"share"])
p[i, "fraction"] <-  p[i,"share"] - p[i, "share_floor"]
}
if(sum(p[, "share_floor"]) == H){
return(p)
} else {
#TODO: Hier den Spaß weiter!! Sortieren und so!
p[["result"]] <- replicate(1, p[["share_floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for(i in H - sum(p[, "share_floor"])){
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(ranks)
}
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H){
P <- sum(p2[,"population"])
A <- P/H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for(i in 1:length(p[["population"]])){
p[i,"share"] <- p[i,"population"]/A
p[i, "share_floor"] <- floor(p[i,"share"])
p[i, "fraction"] <-  p[i,"share"] - p[i, "share_floor"]
}
if(sum(p[, "share_floor"]) == H){
return(p)
} else {
p[["result"]] <- replicate(1, p[["share_floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for(i in H - sum(p[, "share_floor"])){
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return( H - sum(p[, "share_floor"]))
}
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H){
P <- sum(p2[,"population"])
A <- P/H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for(i in 1:length(p[["population"]])){
p[i,"share"] <- p[i,"population"]/A
p[i, "share_floor"] <- floor(p[i,"share"])
p[i, "fraction"] <-  p[i,"share"] - p[i, "share_floor"]
}
if(sum(p[, "share_floor"]) == H){
return(p)
} else {
p[["result"]] <- replicate(1, p[["share_floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for(i in 1:H - sum(p[, "share_floor"])){
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H){
P <- sum(p2[,"population"])
A <- P/H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for(i in 1:length(p[["population"]])){
p[i,"share"] <- p[i,"population"]/A
p[i, "share_floor"] <- floor(p[i,"share"])
p[i, "fraction"] <-  p[i,"share"] - p[i, "share_floor"]
}
if(sum(p[, "share_floor"]) == H){
return(p)
} else {
p[["result"]] <- replicate(1, p[["share_floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for(i in 1:(H - sum(p[, "share_floor"]))){
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H){
P <- sum(p2[,"population"])
A <- P/H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for(i in 1:length(p[["population"]])){
p[i,"share"] <- p[i,"population"]/A
p[i, "share_floor"] <- floor(p[i,"share"])
p[i, "fraction"] <-  p[i,"share"] - p[i, "share_floor"]
}
if(sum(p[, "share_floor"]) == H){
return(p)
}
p[["result"]] <- replicate(1, p[["share_floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for(i in 1:(H - sum(p[, "share_floor"]))){
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
p2 <- data.frame("state"=c("A", "B", "C", "D"), "population" = c(630, 480, 390, 500))
hamilton(p2, 10)
source('E:/Proggen/Git/Hamilton/Hamilton/Hamilton.R')
#Hamilton-Method for the Apportionment Problem
hamilton <- function(p, H) {
P <- sum(p2[, "population"])
A <- P / H
share <- array(0, length(p))
share_floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share_floor"]] <- share_floor
p[["fraction"]] <- fraction
for (i in 1:length(p[["population"]])) {
p[i, "share"] <- p[i, "population"] / A
p[i, "share_floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share_floor"]
}
if (sum(p[, "share_floor"]) == H) {
return(p)
}
p[["result"]] <- replicate(1, p[["share_floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(H - sum(p[, "share_floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
# p2 <-
#   data.frame("state" = c("A", "B", "C", "D"),
#              "population" = c(630, 480, 390, 500))
p2 <- data.frame(state = c("Alan", "Antonio", "Alex", "Lucas"), "population" = c(580, 230, 180, 130))
hamilton(p2, 10)
#Hamilton-Method for the Apportionment Problem
Hamilton <- function(p, H) {
P <- sum(p2[, "population"])
A <- P / H
share <- array(0, length(p))
share.floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share.floor"]] <- share.floor
p[["fraction"]] <- fraction
for (i in 1:length(p[["population"]])) {
p[i, "share"] <- p[i, "population"] / A
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == H) {
return(p)
}
p[["result"]] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(H - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
# p2 <-
#   data.frame("state" = c("A", "B", "C", "D"),
#              "population" = c(630, 480, 390, 500))
p2 <- data.frame(state = c("Alan", "Antonio", "Alex", "Lucas"), "population" = c(580, 230, 180, 130))
Hamilton(p2, 10)
#TODO:
#Evtl. iwas schreiben, damit Eingabe in die Funktion passt
#Wie verpacken?? Wie deployen? Auf den GitLab Server pushen??
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   x: One of two vectors whose sample covariance is to be calculated.
#   y: The other vector. x and y must have the same length, greater than one,
#      with no missing values.
#   verbose: If TRUE, prints sample covariance; if not, not. Default is TRUE.
#
# Returns:
#   The sample covariance between x and y.
psum <- sum(p2[, "population"])
a <- psum / h
share <- array(0, length(p))
share.floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share.floor"]] <- share.floor
p[["fraction"]] <- fraction
for (i in 1:length(p[["population"]])) {
p[i, "share"] <- p[i, "population"] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
# p2 <-
#   data.frame("state" = c("A", "B", "C", "D"),
#              "population" = c(630, 480, 390, 500))
p2 <- data.frame(state = c("Alan", "Antonio", "Alex", "Lucas"), "population" = c(580, 230, 180, 130))
Hamilton(p2, 10)
#TODO:
#Wie verpacken?? Wie deployen? Auf den GitLab Server pushen??
Hamilton <- function(p, h) {
# Implemented Hamilton-Method for the Apportionment Problem
#
# Args:
#   x: a data frame with the names of the states as first column
#     and the equivalent population
#     size in the second column named 'population'.
#   h: the house size as variable.
#
# Returns:
#   A DataFrame containing all the Information
#   and the final result in the last column.
psum <- sum(p2[, "population"])
a <- psum / h
share <- array(0, length(p))
share.floor <- array(0, length(p))
fraction <- array(0, length(p))
p[["share"]] <- share
p[["share.floor"]] <- share.floor
p[["fraction"]] <- fraction
for (i in 1:length(p[["population"]])) {
p[i, "share"] <- p[i, "population"] / a
p[i, "share.floor"] <- floor(p[i, "share"])
p[i, "fraction"] <-  p[i, "share"] - p[i, "share.floor"]
}
if (sum(p[, "share.floor"]) == h) {
return(p)
}
p[["result"]] <- replicate(1, p[["share.floor"]])
ranks <- order(p$fraction, decreasing = TRUE)
for (i in 1:(h - sum(p[, "share.floor"]))) {
p[[ranks[i], "result"]] <-  p[[ranks[i], "result"]] + 1
}
return(p)
}
# p2 <-
#   data.frame("state" = c("A", "B", "C", "D"),
#              "population" = c(630, 480, 390, 500))
p2 <-
data.frame(
state = c("Alan", "Antonio", "Alex", "Lucas"),
"population" = c(580, 230, 180, 130)
)
Hamilton(p2, 10)
#TODO:
#Wie verpacken?? Wie deployen? Auf den GitLab Server pushen??
p2 <- data.frame("state" = c("A", "B", "C", "D"),
"population" = c(630, 480, 390, 500))
Hamilton(p2, 10)
?library
